但是用debug查看并不一样。那么问题在哪里呢？

在网上查看，发现有一个相似问题的解释是这样的：“调试的情况下 是用调试器来实对 单步 断点异常的处理。加载了更多的函数。 当然地址会不一样了。”

我觉得可能是直接运行和debug调试分配的内存空间不一样，如上所说，debug调试要加载更多的函数，所以main函数的段地址会相对较大。

但是这里是子函数和main函数在一个段里，所以子函数的段地址可以在主函数里用_CS

表示，如果子函数和main函数不在一个段里呢？我们知道：用tcc hello.c生成的文件可有两个段，一个为代码段，一个为栈和数据段。所以子函数和主函数都要在同一个代码段里。那么如果代码量超过64kb，一个段存放不下，怎么办？在网上查阅资料如下：
、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、
C 语言中提供了6种编译模式，这6种模式是：

微模式（Tiny），小模式（Small），中模式（Medium），紧凑模式（Compact），大模式（Large）和巨模式（Huge）。它们之间的关系如下图所示。用户可以按照自己的程序大小及需要进行选择。
　　　　　　│ 小程序　　 │ 大程序
　　━━━━┿━━━━━━┿━━━━━━━━
　　 小数据 │ 微，小　　 │ 中
　　 大数据 │ 紧凑　　　 │ 大，巨


　　所谓小程序就是指程序只有一个程序段，大小不超过64KB，缺省的码（函数）指针是near（近程指针）。所谓大程序就是指程序只有多个程序段，每个程序段不超过64KB，但总程序量可超过64KB，缺省的码指针是far（远程指针）。小数据就是指数据只有一个数据段，缺省的数据指针是near。大数据就是指数据有多个数据段，缺省的数据指针是far。

由上可知，我们所说的只有一个代码段的程序是小程序，它的代码不超过64kb，在编译时会以默认的编译模式：小模式来编译。即前面研究里所说的tcc a.c生成的exe文件有一个代码段，一个栈和数据段就可以理解了。我们用TC2.0的时候不可缺少的相关文件里有关编译模式的是c0s.obj和cs.lib，所以TC2.0默认的编译模式是小模式。所以默认的编译只能编译代码量不超过64kb的文件。 
、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、
3、研讨会解决的问题

（5）为何打印出来的段地址的值和用debug调试的时候出来的地址的值是不一样的？

答：编译时给定了偏移地址，载入时cmd或者debug再给定段地址，所以段地址不一样。


（7）为什么打印出来的偏移地址改变，在平常的时候main函数的偏移地址是1fa但是此时的main函数的偏移地址不是这样的了？

答：主函数的偏移地址不一定是1fa，而是第一个程序的偏移地址是1fa。之后函数的偏移地址按程序的长度发生变化。其实原理和汇编语言里不同段的地址不同是一样的。C0s.Obj里的函数加载完后正好到了1fa处应该加载源文件的内容了，这时那个函数在第一个就把哪个函数放在1fa处。
















